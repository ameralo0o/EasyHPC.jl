var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#EasyHPC.insertion_sort!-Tuple{Vector, Int64, Int64, EasyHPC.Ordering}","page":"API Reference","title":"EasyHPC.insertion_sort!","text":"insertion_sort!(v::Vector, o::Ordering)\n\nSimple in-place insertion sort for small arrays. Stable and adaptive to nearly-sorted data.\n\n\n\n\n\n","category":"method"},{"location":"api/#EasyHPC.parall-Tuple{AbstractVector{Bool}}","page":"API Reference","title":"EasyHPC.parall","text":"parall(data::AbstractVector{Bool})\n\nCheck in parallel whether all elements in the boolean vector data are true.\n\nReturns early as soon as a false is found (short-circuiting).\n\nReturns\n\ntrue if all elements are true, otherwise false\n\nExample\n\nparall([true, true, true])    # → true\nparall([true, false, true])   # → false\n\n\n\n\n\n","category":"method"},{"location":"api/#EasyHPC.parall-Tuple{Any}","page":"API Reference","title":"EasyHPC.parall","text":"parall(data)\n\nError fallback method if data is not a Vector{Bool}.\n\nThrows\n\nArgumentError: Always\n\nExample\n\nparall(\"hello\")  # throws error\n\n\n\n\n\n","category":"method"},{"location":"api/#EasyHPC.parall-Tuple{Function, Any}","page":"API Reference","title":"EasyHPC.parall","text":"parall(f, data; nchunks = nthreads())\n\nCheck in parallel whether f(x) returns true for all elements x in data.\n\nShort-circuits and returns false as soon as a failing element is found.\n\nArguments\n\nf: A predicate function\ndata: A collection of values\nnchunks: Number of chunks for parallel evaluation (default: nthreads())\n\nReturns\n\ntrue if f(x) is true for all elements, otherwise false\n\nExample\n\nparall(iseven, [2, 4, 6])     # → true\nparall(iseven, [2, 3, 4])     # → false\n\n\n\n\n\n","category":"method"},{"location":"api/#EasyHPC.parany-Tuple{AbstractVector{Bool}}","page":"API Reference","title":"EasyHPC.parany","text":"parany(data::AbstractVector{Bool})\n\nCheck in parallel whether any element in the boolean vector data is true.\n\nReturns early as soon as a true is found (short-circuiting).\n\nReturns\n\ntrue if any element is true, otherwise false\n\nExample\n\nparany([false, false, true])   # → true\nparany([false, false])         # → false\n\n\n\n\n\n","category":"method"},{"location":"api/#EasyHPC.parany-Tuple{Any}","page":"API Reference","title":"EasyHPC.parany","text":"parany(data)\n\nError fallback method if data is not a Vector{Bool}.\n\nThrows\n\nArgumentError: Always\n\nExample\n\nparany(42)  # throws error\n\n\n\n\n\n","category":"method"},{"location":"api/#EasyHPC.parany-Tuple{Function, Any}","page":"API Reference","title":"EasyHPC.parany","text":"parany(f, data; nchunks = nthreads())\n\nCheck in parallel whether f(x) returns true for any element in data.\n\nShort-circuits as soon as a true result is found.\n\nArguments\n\nf: A predicate function\ndata: A collection of values\nnchunks: Number of chunks for parallel evaluation (default: nthreads())\n\nReturns\n\ntrue if any element satisfies the predicate, otherwise false\n\nExample\n\nparany(isodd, [2, 4, 6])       # → false\nparany(isodd, [2, 3, 4])       # → true\n\n\n\n\n\n","category":"method"},{"location":"api/#EasyHPC.parcount-Tuple{Any, Any}","page":"API Reference","title":"EasyHPC.parcount","text":"parcount(f, data; nchunks = nthreads())\n\nCount the number of elements in data for which the predicate f(x) returns true, using parallel reduction.\n\nFalls back to serial count for small inputs.\n\nArguments\n\nf: A predicate function returning Bool\ndata: A collection of values\nnchunks: Number of chunks (default: nthreads())\n\nReturns\n\nInt: The number of elements satisfying f(x)\n\nThrows\n\nTypeError: If f(x) does not return a Bool (checked on the first element)\n\nExample\n\nparcount(iseven, 1:10)                 # → 5\nparcount(x -> x > 100, [10, 20, 150])  # → 1\n\n\n\n\n\n","category":"method"},{"location":"api/#EasyHPC.parmap-Tuple{Any, Any}","page":"API Reference","title":"EasyHPC.parmap","text":"parmap(f, data; nchunks = nthreads())\n\nApplies the function f to each element of data in parallel, preserving the original order of results.\n\nThe input collection is divided into chunks (default: one per thread), and each chunk is processed concurrently using Threads.@spawn. The result is a Vector of the same length and order as data.\n\nArguments\n\nf: A function to apply to each element (e.g., x -> x^2)\ndata: An indexable collection (typically a Vector or UnitRange) of input values\n\nKeyword Arguments\n\nnchunks: Number of chunks to split the input into (default: nthreads())\n\nReturns\n\nVector{T}: A vector where each element is f(data[i]), computed in parallel\n\nExample\n\njulia> parmap(x -> x^2, 1:5)\n5-element Vector{Int64}:\n 1\n 4\n 9\n 16\n 25\n\nNotes\n\nOutput order always matches input order\nBest suited for pure, side-effect-free functions\nAutomatically infers output element type via Base.promote_op\n\n\n\n\n\n","category":"method"},{"location":"api/#EasyHPC.parmax-Tuple{Any}","page":"API Reference","title":"EasyHPC.parmax","text":"parmax(data)\n\nCompute the maximum value in data using parallel reduction.\n\nArguments\n\ndata: An indexable collection (e.g. Vector, Range) of numeric or orderable values\n\nReturns\n\nThe maximum element of data, computed in parallel\n\nThrows\n\nArgumentError if data is empty\n\nExample\n\nparmax([1, 5, 3, 9])  # → 9\n\n\n\n\n\n","category":"method"},{"location":"api/#EasyHPC.parmin-Tuple{Any}","page":"API Reference","title":"EasyHPC.parmin","text":"parmin(data)\n\nCompute the minimum value in data using parallel reduction.\n\nArguments\n\ndata: An indexable collection of orderable values\n\nReturns\n\nThe minimum element of data, computed in parallel\n\nThrows\n\nArgumentError if data is empty\n\nExample\n\nparmin([3, 7, -2, 10])  # → -2\n\n\n\n\n\n","category":"method"},{"location":"api/#EasyHPC.parsum-Tuple{Any}","page":"API Reference","title":"EasyHPC.parsum","text":"parsum(data; nchunks = nthreads())\n\nCompute the sum of all elements in data in parallel using multithreading.\n\nThe input is split into chunks using OhMyThreads.index_chunks, and each chunk is summed in a separate task. A thread-safe atomic accumulator is used for combining the results.\n\nArguments\n\ndata: A collection (e.g. Vector, Range, etc.) of numeric elements\n\nKeyword Arguments\n\nnchunks: Number of chunks (parallel tasks). Default is nthreads()\n\nReturns\n\nThe total sum of all elements in data, computed in parallel\n\nExample\n\nparsum(1:1_000_000)  # returns 500000500000\n\nNotes\n\nAutomatically adapts to the number of threads via nchunks\nMost efficient on large numeric collections (Vector{Int}, Vector{Float64}, etc.)\n\n\n\n\n\n","category":"method"},{"location":"api/#EasyHPC.sort_numeric!-Union{Tuple{Vector{T}}, Tuple{T}, Tuple{Vector{T}, EasyHPC.Ordering}} where T<:Real","page":"API Reference","title":"EasyHPC.sort_numeric!","text":"sort_numeric!(v::Vector{T}, o::Ordering = Forward()) where {T <: Real}\n\nEfficient in-place parallel sorting for numeric vectors v, using a hybrid introsort strategy with multithreading.\n\nThis function dynamically selects the most efficient sorting method depending on the vector's size and order:\n\nUses insertion_sort! for small vectors (length ≤ SMALL_THRESHOLD)\nDetects already sorted or reverse-sorted input for early return\nUses a parallel introsort (quicksort + heapsort + insertion sort) for general cases\nAutomatically parallelizes using native Julia threads (Threads.@spawn + Channel)\n\nArguments\n\nv: A vector of real numbers (Vector{T} where T <: Real), such as Vector{Int} or Vector{Float64}\no: An Ordering, either Forward() (ascending, default) or Reverse() (descending)\n\nPerformance\n\nVery fast for large numeric vectors\nSupports both Int and Float64\nScales with available threads for vectors larger than PARALLEL_THRESHOLD\n\nExample\n\nv1 = rand(Int, 1_000_000)\nsort_numeric!(v1)  # Ascending sort\n\nv2 = randn(1_000_000)\nsort_numeric!(v2, Reverse())  # Descending sort\n\n\n\n\n\n","category":"method"},{"location":"#EasyHPC.jl","page":"Home","title":"EasyHPC.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides fast and simple parallel operations for CPU-bound workloads, including:","category":"page"},{"location":"","page":"Home","title":"Home","text":"parmap: Parallel map\nparreduce: Parallel reduce\nparsum: Parallel sum\nparcount: Parallel count\nparany / parall: Parallel logical checks\nsort_numeric!: High-performance hybrid parallel sort","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Thread-safe, allocation-efficient implementations\nAutomatic chunking via OhMyThreads.jl\nIn-place and out-of-place support\nWorks with Int, Float64, and other numeric types\nScales well on multi-core machines","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"pkg> add EasyHPC","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here's a simple example using parmap and parreduce:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using EasyHPC\n\ndata = 1:1_000_000\n\n# Square all elements in parallel\nsquares = parmap(x -> x^2, data)\n\n# Sum them using parallel reduction\ntotal = parreduce(+, squares)","category":"page"},{"location":"#Table-of-Contents","page":"Home","title":"Table of Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"index.md\", \"api.md\"]\nDepth = 2","category":"page"},{"location":"","page":"Home","title":"Home","text":"For detailed function reference, see the API Reference.","category":"page"}]
}
